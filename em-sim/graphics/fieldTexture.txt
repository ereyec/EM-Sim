const int nrChannels = 4;
glm::vec3 blue = glm::vec3(0,0,1);

Texturef fieldTextureXZ(sp.x * 2, sp.z * 2);
fieldTextureXZ.data = (float*)malloc(sp.x * 2 * sp.z * 2 * nrChannels * sizeof(float));

//XZ texture layout per yee grid cell
//[   ][Ex]
//[Ez][Hy]

//This will probably be too slow to run at a reasonable pace, in that case we could switch to compute shaders
//for both the simulator and texture writes.
//Fill the texture:
for(int z = 0; z < sp.z; z++){
for(int x = 0; x < sp.x; x++){
	int zSlice = sp.x*4*4;
	int zHalfSlice = sp.x*2*4;
	int xJump = 8;
	int xHalfJump = 4;
	int index00 = fieldTextureXZ.data[zSlice * z + xJump * x];
	int index10 = fieldTextureXZ.data[zSlice * z + xJump * x + xHalfJump];
	int index01 = fieldTextureXZ.data[zSlice * z + xJump * x + zHalfSlice];
	int index11 = fieldTextureXZ.data[zSlice * z + xJump * x + zHalfSlice + xHalfJump];

	fieldTextureXZ.data[index00] = blue.x;
	fieldTextureXZ.data[index00++] = blue.y;
	fieldTextureXZ.data[index00++] = blue.z;
	fieldTextureXZ.data[index00++] = 1.0f;

	float ExClamped = glm::clamp(yeeGrid(x, 0, z).Ex.current, 0, 100);
	float lerpVal = ExClamped / 100.f;
	float blue = 1 - lerpVal;
	float red = lerpVal;
	glm::vec3 color10 = glm::vec3(red, 0, blue);
	
	fieldTextureXZ.data[index10] = color10.x;
	fieldTextureXZ.data[index10++] = color10.y;
	fieldTextureXZ.data[index10++] = color10.z;
	fieldTextureXZ.data[index10++] = 1.0f;
}
}